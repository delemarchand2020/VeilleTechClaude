"""
Point d'entr√©e principal de l'Agent de Veille Intelligente - Version Compl√®te

Orchestrateur des 3 agents : Collecteur ‚Üí Analyseur ‚Üí Synth√©tiseur
G√©n√®re automatiquement un digest quotidien de veille technologique.
"""
import asyncio
import sys
import os
import argparse
from datetime import datetime
from loguru import logger

# Imports de la configuration centralis√©e
from src.utils.config_loader import load_config
from src.models.database import DatabaseManager
from src.agents import (
    TechCollectorAgent, CollectionConfig,
    TechAnalyzerAgent, TechSynthesizerAgent
)


def setup_logging(level: str = "INFO"):
    """Configure le logging."""
    logger.remove()
    logger.add(
        sys.stdout, 
        format="<green>{time:HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{function}</cyan> | {message}",
        level=level
    )


def parse_arguments():
    """Parse les arguments de ligne de commande."""
    parser = argparse.ArgumentParser(
        description="Agent de Veille Intelligente - G√©n√©rateur de digest quotidien",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Exemples d'utilisation:
  python main.py                              # Mode production standard
  python main.py --demo                       # Mode d√©mo rapide
  python main.py --profile expert             # Profil expert
  python main.py --environment development    # Environnement de d√©veloppement
  python main.py --total-limit 20             # Override limite de collecte
  python main.py --target-audience tech_lead  # Override audience cible
        """
    )
    
    # Modes de fonctionnement
    parser.add_argument(
        "--demo", "-d", 
        action="store_true", 
        help="Mode d√©mo avec collecte r√©duite"
    )
    
    # Configuration
    parser.add_argument(
        "--profile", "-p", 
        choices=["demo", "production", "expert"],
        help="Profil de configuration √† utiliser"
    )
    
    parser.add_argument(
        "--environment", "-e", 
        choices=["development", "production"],
        help="Environnement d'ex√©cution"
    )
    
    # Overrides de configuration
    parser.add_argument(
        "--total-limit", 
        type=int, 
        help="Nombre maximum d'articles √† collecter"
    )
    
    parser.add_argument(
        "--target-audience", 
        choices=["senior_engineer", "tech_lead", "architect"],
        help="Audience cible pour le digest"
    )
    
    parser.add_argument(
        "--max-articles", 
        type=int, 
        help="Nombre maximum d'articles dans le digest final"
    )
    
    # Options de sortie
    parser.add_argument(
        "--output-dir", 
        help="R√©pertoire de sortie pour les digests"
    )
    
    # Logging
    parser.add_argument(
        "--log-level", 
        choices=["DEBUG", "INFO", "WARNING", "ERROR"],
        default="INFO",
        help="Niveau de logging"
    )
    
    # Options de d√©bogage
    parser.add_argument(
        "--verbose", "-v", 
        action="store_true", 
        help="Mode verbose (equivalent √† --log-level DEBUG)"
    )
    
    return parser.parse_args()


async def create_daily_digest(profile: str = None, environment: str = None, **overrides):
    """Workflow principal de cr√©ation du digest quotidien."""
    
    logger.info("üöÄ D√âMARRAGE AGENT DE VEILLE INTELLIGENTE")
    logger.info("üéØ G√©n√©ration du digest quotidien GenAI/LLM/Agentic")
    
    start_time = datetime.now()
    
    try:
        # ===============================
        # CONFIGURATION ET VALIDATION
        # ===============================
        logger.info("üîß Chargement de la configuration...")
        config = load_config(profile=profile, environment=environment)
        
        # Application des overrides CLI
        if overrides:
            logger.info(f"üîß Application overrides: {overrides}")
            # Exemple d'overrides
            if 'total_limit' in overrides:
                config.collection.total_limit = overrides['total_limit']
            if 'target_audience' in overrides:
                config.synthesis.target_audience = overrides['target_audience']
            if 'max_articles' in overrides:
                config.synthesis.max_articles_in_digest = overrides['max_articles']
        
        logger.info(f"‚öôÔ∏è Configuration:")
        logger.info(f"   üì° Collecte: {config.collection.total_limit} articles max")
        logger.info(f"   üéØ Audience: {config.synthesis.target_audience}")
        logger.info(f"   üìù Digest: {config.synthesis.max_articles_in_digest} articles")
        
        logger.info("üíæ Initialisation base de donn√©es...")
        db = DatabaseManager()
        
        # Configuration pour la collecte bas√©e sur le config file
        collection_config = CollectionConfig(
            total_limit=config.collection.total_limit,
            source_limits=config.collection.source_limits,
            keywords=config.collection.keywords,
            max_age_days=config.collection.max_age_days,
            enable_deduplication=True
        )
        
        logger.info("‚úÖ Configuration valid√©e")
        
        # ===============================
        # PHASE 1: COLLECTE
        # ===============================
        logger.info("\nüì° PHASE 1: Collecte de contenu...")
        
        collector = TechCollectorAgent(collection_config)
        collection_result = await collector.collect_all_sources()
        
        if collection_result.total_filtered == 0:
            logger.error("‚ùå Aucun contenu collect√© - Arr√™t du processus")
            return None
        
        logger.info(f"‚úÖ Collecte r√©ussie:")
        logger.info(f"   üìä {collection_result.total_collected} articles r√©cup√©r√©s")
        logger.info(f"   ‚úÖ {collection_result.total_filtered} articles filtr√©s")
        logger.info(f"   üîÑ {collection_result.duplicates_removed} doublons supprim√©s")
        logger.info(f"   ‚è±Ô∏è {collection_result.collection_time:.2f}s")
        
        # ===============================
        # PHASE 2: ANALYSE
        # ===============================
        logger.info("\nüß† PHASE 2: Analyse intelligente...")
        
        # Cr√©ation de l'expert profile depuis la config
        from src.models.analysis_models import ExpertProfile, ExpertLevel
        expert_profile = ExpertProfile(
            level=ExpertLevel(config.analysis.expert_level),
            interests=config.analysis.interests,
            avoid_topics=config.analysis.avoid_topics,
            preferred_content_types=config.analysis.preferred_content_types
        )
        
        analyzer = TechAnalyzerAgent(expert_profile)
        analyzed_articles = await analyzer.analyze_contents(collection_result.contents)
        
        if not analyzed_articles:
            logger.error("‚ùå Aucun article analys√© - Arr√™t du processus")
            return None
        
        recommended_articles = [a for a in analyzed_articles if a.analysis.recommended]
        avg_score = sum(a.final_score for a in analyzed_articles) / len(analyzed_articles)
        
        logger.info(f"‚úÖ Analyse r√©ussie:")
        logger.info(f"   üìä {len(analyzed_articles)} articles analys√©s")
        logger.info(f"   üéØ {len(recommended_articles)} articles recommand√©s")
        logger.info(f"   üìà Score moyen: {avg_score:.2f}/1.0")
        
        # ===============================
        # PHASE 3: SYNTH√àSE
        # ===============================
        logger.info("\nüìù PHASE 3: G√©n√©ration du digest...")
        
        # Configuration du synth√©tiseur avec la config centralis√©e
        synthesis_config = {
            "target_audience": config.synthesis.target_audience,
            "max_articles_in_digest": config.synthesis.max_articles_in_digest,
            "executive_summary_max_words": config.synthesis.executive_summary_max_words,
            "article_summary_max_words": config.synthesis.article_summary_max_words,
            "max_insights": config.synthesis.max_insights,
            "max_recommendations": config.synthesis.max_recommendations,
            "include_technical_trends": config.synthesis.include_technical_trends,
            "include_action_items": config.synthesis.include_action_items,
            "tone": config.synthesis.tone,
            "technical_depth": config.synthesis.technical_depth,
            "focus_areas": config.synthesis.focus_areas
        }
        
        synthesizer = TechSynthesizerAgent(synthesis_config)
        daily_digest = await synthesizer.create_daily_digest(analyzed_articles)
        
        # Sauvegarde du digest selon la config output
        output_path = await synthesizer.save_digest_to_file(
            daily_digest, 
            output_dir=config.output.reports_dir
        )
        
        logger.info(f"‚úÖ Digest g√©n√©r√©:")
        logger.info(f"   üìã {daily_digest.title}")
        logger.info(f"   üìÑ {daily_digest.word_count} mots ({daily_digest.estimated_read_time}min)")
        logger.info(f"   üèÜ {len(daily_digest.top_articles)} articles vedettes")
        logger.info(f"   üí° {len(daily_digest.key_insights)} insights cl√©s")
        logger.info(f"   üéØ {len(daily_digest.recommendations)} recommandations")
        logger.info(f"   üíæ Sauvegard√©: {output_path}")
        
        # ===============================
        # R√âSUM√â FINAL
        # ===============================
        total_time = (datetime.now() - start_time).total_seconds()
        
        logger.info(f"\nüéâ DIGEST QUOTIDIEN G√âN√âR√â AVEC SUCC√àS!")
        logger.info(f"‚è±Ô∏è Temps total: {total_time:.2f}s")
        logger.info(f"üìä Performance: {total_time/len(analyzed_articles):.2f}s/article")
        logger.info(f"üìÑ Fichier: {output_path}")
        
        # Aper√ßu du contenu
        logger.info(f"\nüìã APER√áU DU DIGEST:")
        logger.info(f"üó∫Ô∏è {daily_digest.title}")
        
        # Top articles
        for i, article in enumerate(daily_digest.top_articles[:2], 1):
            logger.info(f"   {i}. {article.title_refined}")
            logger.info(f"      üìä Score: {article.relevance_for_audience:.2f} | {article.complexity_level}")
        
        # Top insights
        for insight in daily_digest.key_insights[:2]:
            logger.info(f"   üí° {insight}")
        
        return {
            'digest': daily_digest,
            'output_path': output_path,
            'stats': {
                'collection': collection_result,
                'analysis': analyzed_articles,
                'total_time': total_time
            }
        }
        
    except Exception as e:
        logger.error(f"‚ùå Erreur lors de l'ex√©cution: {e}")
        logger.exception("D√©tails de l'erreur:")
        raise


def main():
    """Fonction principale avec gestion des arguments CLI."""
    
    # Parse des arguments
    args = parse_arguments()
    
    # Configuration du logging
    log_level = "DEBUG" if args.verbose else args.log_level
    setup_logging(log_level)
    
    # D√©termination du profil et environnement
    profile = args.profile or ("demo" if args.demo else None)
    environment = args.environment
    
    # Pr√©paration des overrides
    overrides = {}
    if args.total_limit:
        overrides['total_limit'] = args.total_limit
    if args.target_audience:
        overrides['target_audience'] = args.target_audience  
    if args.max_articles:
        overrides['max_articles'] = args.max_articles
    
    # Log des param√®tres d'ex√©cution
    logger.info("üöÄ Agent de Veille Intelligente")
    if profile:
        logger.info(f"üìã Profil: {profile}")
    if environment:
        logger.info(f"üåç Environnement: {environment}")
    if overrides:
        logger.info(f"üîß Overrides: {overrides}")
    
    try:
        # Ex√©cution principale
        result = asyncio.run(create_daily_digest(
            profile=profile,
            environment=environment,
            **overrides
        ))
        
        if result:
            logger.info("üéâ Traitement termin√© avec succ√®s!")
            
            # Affichage des statistiques finales
            stats = result['stats']
            logger.info(f"üìä Statistiques finales:")
            logger.info(f"   üì° Collect√©s: {stats['collection'].total_collected}")
            logger.info(f"   üß† Analys√©s: {len(stats['analysis'])}")
            logger.info(f"   ‚è±Ô∏è Dur√©e totale: {stats['total_time']:.1f}s")
            logger.info(f"   üìÑ Fichier: {result['output_path']}")
        else:
            logger.error("‚ùå √âchec du traitement")
            sys.exit(1)
            
    except KeyboardInterrupt:
        logger.warning("‚ö†Ô∏è Interruption utilisateur")
        sys.exit(130)
    except Exception as e:
        logger.error(f"‚ùå Erreur fatale: {e}")
        if log_level == "DEBUG":
            logger.exception("D√©tails:")
        sys.exit(1)


if __name__ == "__main__":
    main()
